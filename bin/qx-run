#!/usr/bin/env python3
import argparse, json, sys, runpy
from qx import backend, run


def _load_module_build(path):
    # execute the module file and expect a build() function returning a Circuit
    ns = runpy.run_path(path)
    if "build" not in ns:
        raise SystemExit(2)
    return ns["build"]()


def main():
    ap = argparse.ArgumentParser(description="Run a circuit module on a backend")
    ap.add_argument("--module", help="path to a .py file that exposes build() -> Circuit")
    ap.add_argument("--target", default="sim-local", help="sim-local or path to target json")
    ap.add_argument("--shots", type=int, default=1024)
    ap.add_argument("--max-qubits", type=int, help="Override max qubits for this process (sets QX_MAX_QUBITS)")
    ap.add_argument("--seed", type=int, help="Deterministic RNG seed to use for this run")
    args = ap.parse_args()

    if not args.module:
        ap.error("--module is required")

    try:
        qc = _load_module_build(args.module)
    except SystemExit:
        print("Module missing build()")
        return 2

    # optionally override process-level QX_MAX_QUBITS (do this before creating backend so caps reflect it)
    if getattr(args, "max_qubits", None) is not None:
        # set central config (mirrors into env for compatibility)
        from qx.config import set_max_qubits
        set_max_qubits(args.max_qubits)
    b = backend(args.target)
    job = run(qc, b, shots=args.shots, seed=getattr(args, "seed", None))
    res = job.result()
    # Add a human-friendly header for legacy tests/tools that expect it
    print("Counts")
    print(json.dumps({"counts": res.counts, "metadata": res.metadata}, indent=2))
    return 0


if __name__ == "__main__":
    sys.exit(main())
